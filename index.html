<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>YOLO Eye Capture</title>

<style>
  :root{--bg:#0b1220;--card:#111827;--muted:#94a3b8;--ok:#22c55e;--text:#e5e7eb;--border:#1f2937}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial}
  header{padding:14px 12px;text-align:center;border-bottom:1px solid var(--border);background:#0b1220cc;backdrop-filter:blur(6px);position:sticky;top:0;z-index:30}
  main{max-width:980px;margin:10px auto 28px;padding:0 14px}
  .card{background:#111827e6;border:1px solid var(--border);border-radius:14px;overflow:hidden;box-shadow:0 8px 26px rgba(0,0,0,.4)}
  .section{padding:14px;border-top:1px dashed var(--border)} .section:first-child{border-top:none}
  .grid{display:grid;gap:14px} @media(min-width:900px){.grid{grid-template-columns:1.2fr .8fr}}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  input[type="text"]{width:260px;padding:10px;border-radius:10px;border:1px solid #334155;background:#0b1220;color:var(--text)}
  input[type="checkbox"]{transform:scale(1.2)}
  button{padding:10px 14px;border-radius:12px;border:1px solid var(--border);background:#0b1220;color:#e5e7eb;cursor:pointer}
  button.primary{background:linear-gradient(180deg,#16a34a,#16a34a 60%,#15803d);border-color:#14532d}
  button:disabled{opacity:.5;cursor:not-allowed}
  .video-wrap{position:relative;border-radius:14px;overflow:hidden;border:1px solid var(--border)}
  video,canvas{display:block;width:100%;height:auto}
  canvas.overlay{position:absolute;inset:0;pointer-events:none;background:transparent !important}
  .muted{color:var(--muted)} .ok{color:#22c55e} .err{color:#ef4444}
  .kbd{font-family:ui-monospace,monospace;background:#111827;border:1px solid var(--border);border-bottom-width:3px;padding:2px 6px;border-radius:6px;color:#cbd5e1}
  .thumbs-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .thumbs-grid img{width:100%;border-radius:10px;border:1px solid var(--border)}
  .toolbar{position:sticky;top:54px;z-index:20;display:grid;grid-template-columns:1fr auto 1fr;align-items:center;gap:10px;padding:6px 10px;margin:8px 0 0;background:#0b1220e0;border:1px solid var(--border);border-radius:10px;backdrop-filter:blur(6px)}
  .toolbar .left,.toolbar .right{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .toolbar .center{display:flex;align-items:center;justify-content:center}
  .btn-capture{padding:12px 20px;border-radius:999px;font-size:1.05rem}
  .unmirror{transform:scaleX(-1);transform-origin:center}
  #consent{position:fixed;inset:0;background:#000000d9;display:flex;align-items:center;justify-content:center;z-index:40}
  #consent .box{max-width:680px;background:#0f172a;border:1px solid var(--border);border-radius:14px;padding:18px}

  /* ‚úÖ Aviso de √©xito */
  #doneMessage {
    display: none;
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    background: #16a34a;
    color: white;
    padding: 14px 24px;
    border-radius: 10px;
    font-weight: 600;
    font-size: 1rem;
    box-shadow: 0 4px 18px rgba(0,0,0,0.35);
    z-index: 100;
    animation: fadeInOut 3.8s ease-in-out forwards;
  }
  @keyframes fadeInOut {
    0% { opacity: 0; transform: translate(-50%, 15px); }
    10%, 85% { opacity: 1; transform: translate(-50%, 0); }
    100% { opacity: 0; transform: translate(-50%, -15px); }
  }
</style>

<!-- ONNX Runtime (YOLO en navegador) -->
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>

<header><strong>YOLO Eye Capture</strong></header>

<!-- Consent -->
<div id="consent">
  <div class="box">
    <h2>Consent & Identification</h2>
    <p class="muted">By pressing ‚ÄúI agree‚Äù, you authorize the use of your eye image exclusively for scientific/research purposes.</p>
    <div class="row" style="margin-top:8px">
      <input id="name" type="text" placeholder="Participant name"/>
      <label class="row" style="gap:8px"><input id="consentChk" type="checkbox"> I agree</label>
    </div>
    <div class="row" style="margin-top:10px">
      <button id="consentOk" class="primary" type="button">Continue</button>
    </div>
  </div>
</div>

<main>
  <div class="toolbar">
    <div class="left">
      <button id="start" class="primary" disabled>Start</button>
      <button id="flip" disabled>Switch</button>
      <button id="flashBtn" disabled title="Rear: torch (if supported). Front: no flash.">Flash: On</button>
    </div>
    <div class="center">
      <button id="capture" class="primary btn-capture" disabled>Capture</button>
    </div>
    <div class="right muted">
      <span id="modelStatus">Model: not loaded</span>
      <span>&nbsp;‚Ä¢&nbsp;</span><span id="fps">‚Äî fps</span>
    </div>
  </div>

  <div class="card" style="margin-top:10px">
    <div class="section grid">
      <div>
        <h2>Instructions</h2>
        <ol class="muted" style="line-height:1.6">
          <li>Press the start button.</li>
          <li>Position yourself in front of the camera (preferably use back camera with flash).</li>
          <li>Focus your eye on the camera.</li>
          <li>Keep a distance of ~10‚Äì15 cm.</li>
          <li>Wait approximately 10 seconds until the software detects the eye (it will draw a box around the eye).</li>
          <li>Align your eye to the horizontal yellow line.</li>
          <li>When the box is shown and the eye is centered, press ‚ÄúCapture‚Äù.</li>
          <li>You can take up to four photos.</li>
        </ol>
      </div>
      <div class="muted">
        <div>Camera: <span id="camLabel" class="kbd">‚Äî</span></div>
        <div style="margin-top:6px">Status: <span id="consentStatus" class="err">Consent/name missing</span></div>
      </div>
    </div>

    <div class="section">
      <div class="video-wrap">
        <video id="video" playsinline muted></video>
        <canvas id="overlay" class="overlay"></canvas>
      </div>
    </div>

    <div class="section grid">
      <div>
        <h3>Result</h3>
        <div class="thumbs-grid">
          <img id="thumb1" alt="Eye crop 1"/>
          <img id="thumb2" alt="Eye crop 2"/>
          <img id="thumb3" alt="Eye crop 3"/>
          <img id="thumb4" alt="Eye crop 4"/>
        </div>
      </div>
      <div>
        <h3>Upload</h3>
        <p class="muted">The cropped eye image(s) will be uploaded to Google Drive.</p>
        <div id="uploadLog" class="muted" style="font-family:ui-monospace,monospace">Ready.</div>
      </div>
    </div>
  </div>
</main>

<!-- ‚úÖ Mensaje de confirmaci√≥n -->
<div id="doneMessage">‚úÖ Eye capture completed successfully!</div>

<script>
/* ================= CONFIG ================= */
const MODEL_URL = "https://huggingface.co/pedro123gtz/yolo-eye-model/resolve/main/best.onnx";
const DRIVE_WEBAPP_URL = "https://script.google.com/macros/s/AKfycbyGGesWH4eSMQIuypuX-vmxarAbSAyNy3JaW25W3JhE4IHTmkyZVDU6WzcHDldITTCqZQ/exec";
const MODEL_INPUT_SIZE = 320;
const MODEL_CONF_THRESHOLD = 0.35;
const MODEL_IOU_THRESHOLD = 0.45;
const UNMIRROR_FRONT = true;

/* ================= DOM & STATE ================= */
const $ = s => document.querySelector(s);
const consent = $("#consent"), nameInput = $("#name"), chk = $("#consentChk"), okBtn = $("#consentOk");
const consentStatus = $("#consentStatus");
const startBtn = $("#start"), flipBtn = $("#flip"), captureBtn = $("#capture"), flashBtn = $("#flashBtn");
const modelStatus = $("#modelStatus"), fpsLabel = $("#fps"), camLabel = $("#camLabel");
const video = $("#video"), overlay = $("#overlay"), ctx = overlay.getContext("2d");
const thumbs = [$("#thumb1"), $("#thumb2"), $("#thumb3"), $("#thumb4")];
const uploadLog = $("#uploadLog");

let streaming=false, currentStream=null, videoTrack=null, useFront=true, track=null, audioCtx=null;
let flashEnabled=true, tick=0, lockedBeeped=false;

/* NUEVAS VARIABLES PARA LA L√çNEA Y EL CONTEO */
let centerLineY = null;
let manualCount = 0;

/* ================= CONSENT ================= */
function updateConsent(){
  const ok = !!nameInput.value.trim() && chk.checked;
  consentStatus.textContent = ok ? "Ready" : "Consent/name missing";
  consentStatus.className = ok ? "ok" : "err";
  startBtn.disabled = !ok;
}
nameInput.addEventListener('input', updateConsent);
chk.addEventListener('change', updateConsent);

okBtn.addEventListener('click', () => {
  if (!nameInput.value.trim() || !chk.checked){
    alert('Please enter your name and check ‚ÄúI agree‚Äù.');
    return;
  }
  consent.style.display = 'none';
  startBtn.disabled = false;
  flashBtn.disabled = false;
  flipBtn.disabled = false;
  updateFlashBtn();
});

/* ================= SOUND ================= */
function beep(freq=880, dur=120, type='sine', gain=0.06){
  try{
    if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    const osc=audioCtx.createOscillator(), g=audioCtx.createGain();
    osc.type=type; osc.frequency.value=freq; g.gain.value=gain;
    osc.connect(g).connect(audioCtx.destination);
    osc.start(); setTimeout(()=>osc.stop(),dur);
  }catch(e){}
}

/* ================= FLASH (Torch) ================= */
function updateFlashBtn(){ flashBtn.textContent = flashEnabled ? 'Flash: On' : 'Flash: Off'; }

async function setTorch(on){
  try{
    if(!videoTrack || typeof videoTrack.getCapabilities!=='function') return false;
    const caps = videoTrack.getCapabilities();
    if(!('torch' in caps)) return false;
    await videoTrack.applyConstraints({ advanced: [{ torch: !!on }] });
    return true;
  }catch(e){ return false; }
}
async function applyFlashState(){
  if (!videoTrack || useFront) { await setTorch(false); return; }
  await setTorch(!!flashEnabled);
}
flashBtn.addEventListener('click', async ()=>{
  flashEnabled = !flashEnabled;
  updateFlashBtn();
  await applyFlashState();
});

/* ================= START CAMERA ================= */
async function startCam() {
  try {
    if (currentStream) currentStream.getTracks().forEach(t => t.stop());
    const facing = useFront ? 'user' : 'environment';
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: facing }, width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false
    });
    currentStream = stream;
    video.srcObject = stream;
    await video.play();

    overlay.width = video.videoWidth;
    overlay.height = video.videoHeight;

    videoTrack = stream.getVideoTracks()[0];
    streaming = true;

    flipBtn.disabled = false;
    flashBtn.disabled = false;

    camLabel.textContent = useFront ? "front" : "back";

    const mirror = UNMIRROR_FRONT && useFront;
    video.classList.toggle('unmirror', mirror);
    overlay.classList.toggle('unmirror', mirror);

    // Torch auto ON en trasera, OFF en frontal
    flashEnabled = !useFront;
    await applyFlashState();
    updateFlashBtn();

    // definir posici√≥n de la l√≠nea horizontal
    centerLineY = overlay.height / 2;

    console.log(`Camera started (${useFront ? "front" : "back"})`);
  } catch (err) {
    console.error("Error starting camera:", err);
    alert("Camera access error. Please check permissions or device availability.");
  }
}

/* ================= SWITCH CAMERA ================= */
flipBtn.addEventListener('click', async () => {
  try {
    useFront = !useFront;
    lockedBeeped = false;
    await setTorch(false);
    await startCam();
    flashEnabled = !useFront;
    await applyFlashState();
    updateFlashBtn();
    console.log(useFront ? "Using front camera (flash off)" : "Torch enabled automatically for back camera");
  } catch (err) {
    console.error("Error switching camera:", err);
    alert("Unable to switch camera. Please check permissions or available devices.");
  }
});

/* ================= START (load model + loop) ================= */
startBtn.addEventListener('click', async () => {
  await startCam();
  if (!eyeapi.nets.eyeDetector.session) {
    await loadModel();
  }
  detectLoop();
});

/* =================== YOLO API =================== */
window.eyeapi=(function(){
  const api={};
  api.nets={eyeDetector:{session:null,async loadFromUrl(url,providers=['webgpu','wasm']){
    for(const ep of providers){
      try{
        this.session=await ort.InferenceSession.create(url,{executionProviders:[ep]});
        return{provider:ep};
      }catch(e){}
    }
    throw new Error('Model load failed');
  }}};
  class Opts{
    constructor({inputSize=MODEL_INPUT_SIZE,confThreshold=MODEL_CONF_THRESHOLD,iouThreshold=MODEL_IOU_THRESHOLD}={}){
      Object.assign(this,{inputSize,confThreshold,iouThreshold});
    }
  }
  api.EyeDetectorOptions=Opts;

  function letterbox(img,S){
    const iw=img.videoWidth||img.width, ih=img.videoHeight||img.height;
    const r=Math.min(S/iw,S/ih), nw=Math.round(iw*r), nh=Math.round(ih*r);
    const dx=Math.floor((S-nw)/2), dy=Math.floor((S-nh)/2);
    const c=document.createElement('canvas'); c.width=S; c.height=S;
    const t=c.getContext('2d'); t.fillStyle='#000'; t.fillRect(0,0,S,S); t.drawImage(img,0,0,iw,ih,dx,dy,nw,nh);
    return {canvas:c,ratio:r,dx,dy,iw,ih};
  }
  function post(out,m,ct,iouT){
    let d=out.data, nb,na;
    if(out.dims.length===3){
      const[n,a,b]=out.dims; nb=b; na=a;
      const tr=new Float32Array(nb*na);
      for(let i=0;i<a;i++)for(let j=0;j<b;j++)tr[j*na+i]=d[i*b+j];
      d=tr;
    } else { nb=out.dims[0]; na=out.dims[1]; }
    const s=x=>1/(1+Math.exp(-x)), boxes=[],scores=[];
    for(let i=0;i<nb;i++){
      const off=i*na, x=d[off],y=d[off+1],w=d[off+2],h=d[off+3],obj=s(d[off+4]);
      let cls=1;
      if(na>5){ let best=0; for(let c=5;c<na;c++){ const sc=s(d[off+c]); if(sc>best) best=sc; } cls=best; }
      const conf=obj*cls; if(conf<ct) continue;
      boxes.push([x-w/2,y-h/2,x+w/2,y+h/2]); scores.push(conf);
    }
    const keep=(function(B,S,iou,maxDet=50){
      const ord=S.map((v,i)=>[v,i]).sort((A,B)=>B[0]-A[0]).map(x=>x[1]);
      const out=[]; function IOU(a,b){const x1=Math.max(a[0],b[0]),y1=Math.max(a[1],b[1]),x2=Math.min(a[2],b[2]),y2=Math.min(a[3],b[3]);
        const w=Math.max(0,x2-x1),h=Math.max(0,y2-y1),inter=w*h,A=(a[2]-a[0])*(a[3]-a[1]),B=(b[2]-b[0])*(b[3]-b[1]); return inter/(A+B-inter+1e-6);}
      for(const i of ord){ let ok=true; for(const j of out){ if(IOU(B[i],B[j])>iou){ok=false;break;} } if(ok){ out.push(i); if(out.length>=maxDet) break; } }
      return out;
    })(boxes,scores,iouT);
    const res=[]; for(const i of keep){
      const [x1,y1,x2,y2]=boxes[i],{ratio,dx,dy,iw,ih}=m;
      const sx1=(x1-dx)/ratio, sy1=(y1-dy)/ratio, sx2=(x2-dx)/ratio, sy2=(y2-dy)/ratio;
      const X1=Math.max(0,Math.min(iw,sx1)), Y1=Math.max(0,Math.min(ih,sy1)), X2=Math.max(0,Math.min(iw,sx2)), Y2=Math.max(0,Math.min(ih,sy2));
      res.push({box:[X1,Y1,X2,Y2],score:scores[i]});
    }
    return res;
  }
  api.detectAllEyes=async function(input,opt=new Opts()){
    const sess=api.nets.eyeDetector.session;
    const lb=letterbox(input,opt.inputSize);
    const px=lb.canvas.getContext('2d').getImageData(0,0,lb.canvas.width,lb.canvas.height).data;
    const size=opt.inputSize*opt.inputSize, arr=new Float32Array(size*3);
    for(let i=0,p=0;i<size;i++,p+=4){arr[i]=px[p]/255;arr[i+size]=px[p+1]/255;arr[i+2*size]=px[p+2]/255;}
    const t0=performance.now();
    const out=await sess.run({[sess.inputNames[0]]:new ort.Tensor('float32',arr,[1,3,opt.inputSize,opt.inputSize])});
    fpsLabel.textContent = `${(1000/(performance.now()-t0)).toFixed(1)} fps`;
    return post(out[sess.outputNames[0]],lb,opt.confThreshold,MODEL_IOU_THRESHOLD);
  };
  return api;
})();

/* ============== LOAD MODEL ============== */
async function loadModel(){
  modelStatus.textContent = 'Model: loading‚Ä¶';
  try {
    const {provider}=await eyeapi.nets.eyeDetector.loadFromUrl(MODEL_URL,['webgpu','wasm']);
    // warm-up
    const tmp=document.createElement('canvas'); tmp.width=MODEL_INPUT_SIZE; tmp.height=MODEL_INPUT_SIZE;
    const tctx=tmp.getContext('2d'); tctx.fillStyle='#000'; tctx.fillRect(0,0,MODEL_INPUT_SIZE,MODEL_INPUT_SIZE);
    await eyeapi.detectAllEyes(tmp,new eyeapi.EyeDetectorOptions({inputSize:MODEL_INPUT_SIZE,confThreshold:0.99}));
    modelStatus.textContent = `Model: ready (${provider})`;
    console.log("YOLO eye detector loaded successfully.");
  } catch (e) {
    console.error("Error loading model:", e);
    modelStatus.textContent = 'Model: load error';
  }
}

/* ======= L√çNEA HORIZONTAL ======= */
function drawCenterLine() {
  if (centerLineY == null) return;
  ctx.beginPath();
  ctx.strokeStyle = "rgba(255,255,0,0.9)";
  ctx.lineWidth = 3;
  ctx.moveTo(0, centerLineY);
  ctx.lineTo(overlay.width, centerLineY);
  ctx.stroke();
}

/* (Opcional) checar alineaci√≥n, por si luego quieres usarlo */
function isEyeAligned(det) {
  if (!det || centerLineY == null) return true; // por ahora no bloquea
  const [x1, y1, x2, y2] = det.box;
  const eyeCenterY = (y1 + y2) / 2;
  const tolerance = (y2 - y1) * 0.15;
  return Math.abs(eyeCenterY - centerLineY) < tolerance;
}

/* ============== DETECTION LOOP ============== */
async function detectLoop() {
  const opts = new eyeapi.EyeDetectorOptions({
    inputSize: MODEL_INPUT_SIZE,
    confThreshold: MODEL_CONF_THRESHOLD,
    iouThreshold: MODEL_IOU_THRESHOLD
  });

  while (streaming) {
    try {
      const dets = await eyeapi.detectAllEyes(video, opts);

      ctx.clearRect(0, 0, overlay.width, overlay.height);
      drawCenterLine();  // <--- SOLO AGREGAMOS ESTO

      if (dets && dets.length > 0) {
        const best = dets[0];
        const [x1, y1, x2, y2] = best.box;

        ctx.lineWidth = 3;
        ctx.strokeStyle = "#22c55e";
        ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);

        if (!lockedBeeped) {
          beep(1175,140,'square',0.08);
          lockedBeeped = true;
          captureBtn.disabled = false;
        }
        track = best;
      } else {
        track = null;
        lockedBeeped = false;
        if (!captureBtn.dataset.locked) {
          captureBtn.disabled = true;
        }
      }
    } catch (err) {
      console.error("Detection error:", err);
    }
    await new Promise((r) => setTimeout(r, 80));
  }
}

/* ============== CAPTURE ============== */
function cropToBlob(det){
  const [x1,y1,x2,y2]=det.box;
  const W=Math.max(1,Math.round(x2-x1)), H=Math.max(1,Math.round(y2-y1));
  const c=document.createElement('canvas'); c.width=W; c.height=H;
  c.getContext('2d').drawImage(video,Math.round(x1),Math.round(y1),W,H,0,0,W,H);
  return new Promise(res=>c.toBlob(b=>res(b),'image/jpeg',0.95));
}

/* üëá Nuevo comportamiento: 1 foto por click, hasta 4 fotos */
captureBtn.addEventListener('click', async () => {
  if (!track) return;

  // Opcional: si quieres obligar alineaci√≥n, descomenta:
  // if (!isEyeAligned(track)) {
  //   alert("Align your eye with the yellow line before capturing.");
  //   return;
  // }

  if (manualCount >= 4) {
    captureBtn.disabled = true;
    return;
  }

  beep(1319,100,'square',0.12);

  const blob = await cropToBlob(track);

  // Mostrar en thumbnail
  thumbs[manualCount].src = URL.createObjectURL(blob);

  // Subir
  await uploadToDrive(blob);

  manualCount += 1;

  if (manualCount >= 4) {
    showDoneMessage();
    captureBtn.disabled = true;
    captureBtn.dataset.locked = "1";
    captureBtn.textContent = "‚úîÔ∏è Completed";
    captureBtn.style.opacity = "0.6";
    captureBtn.style.cursor = "not-allowed";
  }
});

/* ============== UPLOAD + SUCCESS MESSAGE ============== */
function blobToBase64(blob){
  return new Promise((resolve,reject)=>{
    const fr=new FileReader();
    fr.onload=()=>resolve(fr.result.split(',')[1]);
    fr.onerror=reject;
    fr.readAsDataURL(blob);
  });
}
async function uploadToDrive(blob){
  const user=(nameInput.value||'anonymous').trim();
  try{
    const base64=await blobToBase64(blob);
    await fetch(DRIVE_WEBAPP_URL,{
      method:'POST',
      mode:'cors',
      headers:{'Content-Type':'application/x-www-form-urlencoded;charset=UTF-8'},
      body:new URLSearchParams({image:base64,name:user})
    });
    uploadLog.textContent='Uploaded successfully.';
  }catch(e){
    uploadLog.textContent='Upload failed.';
  }
}

function showDoneMessage(){
  const msg=document.getElementById("doneMessage");
  msg.style.display="block";
  setTimeout(()=>{msg.style.display="none";},3800);
}

/* ============== INIT ============== */
(function init(){ updateConsent(); updateFlashBtn(); })();
</script>
</body>
</html>
